#!/usr/bin/env bash
# episodic-deep-dive: Generate comprehensive codebase deep-dive documents
set -euo pipefail

BIN_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$BIN_DIR/../lib/deep-dive.sh"
[[ -f "$BIN_DIR/../lib/knowledge.sh" ]] && source "$BIN_DIR/../lib/knowledge.sh"

usage() {
    cat <<EOF
Usage: episodic-deep-dive [OPTIONS]

Generate a comprehensive deep-dive analysis of a project codebase.

Options:
  --project NAME      Project name (default: derived from --path or CWD)
  --path PATH         Project directory path (default: CWD)
  --refresh           Update existing deep-dive (adds "Changes" section)
  --force             Regenerate even if deep-dive already exists
  --dry-run           Show collected context without calling API
  -h, --help          Show this help

The deep-dive document covers: overview, tech stack, architecture,
directory structure, entry points, key patterns, dependencies,
deployment, dev workflow, and gotchas.

Stored at: ~/.claude/knowledge/<project>/deep-dive.md
EOF
}

PROJECT=""
PROJECT_PATH=""
REFRESH=""
FORCE=""
DRY_RUN=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --project) PROJECT="$2"; shift 2 ;;
        --path) PROJECT_PATH="$2"; shift 2 ;;
        --refresh) REFRESH="--refresh"; shift ;;
        --force) FORCE="true"; shift ;;
        --dry-run) DRY_RUN="true"; shift ;;
        -h|--help) usage; exit 0 ;;
        *) echo "Unknown option: $1" >&2; exit 1 ;;
    esac
done

# Default path to CWD
if [[ -z "$PROJECT_PATH" ]]; then
    PROJECT_PATH="${CWD:-$(pwd)}"
fi

# Default project name from path
if [[ -z "$PROJECT" ]]; then
    PROJECT=$(basename "$PROJECT_PATH")
fi

# Validate path exists
if [[ ! -d "$PROJECT_PATH" ]]; then
    echo "ERROR: Project path does not exist: $PROJECT_PATH" >&2
    exit 1
fi

# Dry run: show context and exit
if [[ "$DRY_RUN" == "true" ]]; then
    echo "=== DRY RUN: Deep Dive for $PROJECT ==="
    echo "Project: $PROJECT"
    echo "Path: $PROJECT_PATH"
    echo ""
    echo "=== Collected Context ==="
    episodic_deep_dive_collect_context "$PROJECT_PATH"
    echo ""
    echo "=== End Context ==="
    echo "Would call ${EPISODIC_DEEP_DIVE_MODEL} API with ${EPISODIC_DEEP_DIVE_THINKING_BUDGET} token thinking budget."
    exit 0
fi

# Check if deep-dive already exists (skip unless --refresh or --force)
if episodic_deep_dive_exists "$PROJECT"; then
    if [[ -z "$REFRESH" && "$FORCE" != "true" ]]; then
        echo "Deep dive already exists for $PROJECT. Use --refresh to update or --force to regenerate."
        exit 0
    fi
    if [[ "$FORCE" == "true" ]]; then
        REFRESH=""  # Force means full regeneration, not refresh
    fi
fi

echo "Generating deep dive for $PROJECT..."
echo "  Path: $PROJECT_PATH"
echo "  Model: $EPISODIC_DEEP_DIVE_MODEL"
echo "  Thinking budget: $EPISODIC_DEEP_DIVE_THINKING_BUDGET tokens"
if [[ -n "$REFRESH" ]]; then
    echo "  Mode: refresh (updating existing)"
fi

# Generate
content=$(episodic_deep_dive_generate "$PROJECT" "$PROJECT_PATH" "$REFRESH")
if [[ -z "$content" ]]; then
    echo "ERROR: Failed to generate deep dive" >&2
    exit 1
fi

# Write
episodic_deep_dive_write "$PROJECT" "$content" "$PROJECT_PATH" "$EPISODIC_DEEP_DIVE_MODEL"

echo "Deep dive written to: $EPISODIC_KNOWLEDGE_DIR/$PROJECT/deep-dive.md"

# Push to knowledge repo if configured
if type episodic_knowledge_is_configured &>/dev/null && episodic_knowledge_is_configured; then
    episodic_knowledge_push "Deep dive: $PROJECT" 2>/dev/null || true
    echo "Pushed to knowledge repo."
fi
